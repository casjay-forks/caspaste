
// This file is part of CasPaste.

// CasPaste is free software released under the MIT License.
// See LICENSE.md file for details.

// Package completions provides shell completion generation for CLI binaries.
// Per AI.md PART 8/33: ALL binaries MUST support built-in shell completions.
package completions

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Handle processes --shell commands and returns true if handled (exit after).
// Usage: --shell completions [SHELL] or --shell init [SHELL]
func Handle(args []string) bool {
	if len(args) < 2 || args[0] != "--shell" {
		return false
	}

	subCmd := args[1]
	if subCmd == "--help" {
		printShellHelp()
		os.Exit(0)
		return true
	}

	shell := ""
	if len(args) > 2 {
		shell = args[2]
	} else {
		shell = detectShell()
	}

	binaryName := filepath.Base(os.Args[0])

	switch subCmd {
	case "completions":
		printCompletions(shell, binaryName)
		os.Exit(0)
		return true
	case "init":
		printInit(shell, binaryName)
		os.Exit(0)
		return true
	default:
		fmt.Fprintf(os.Stderr, "Unknown shell command: %s\n", subCmd)
		fmt.Fprintln(os.Stderr, "Usage: --shell [completions|init] [SHELL]")
		os.Exit(1)
		return true
	}
}

func printShellHelp() {
	fmt.Println(`Shell Completion Integration

Usage:
  --shell completions [SHELL]   Print shell completion script to stdout
  --shell init [SHELL]          Print shell init command for eval
  --shell --help                Show this help

Supported shells:
  bash        Bash completions (full support)
  zsh         Zsh completions (full support)
  fish        Fish completions (full support)
  sh          POSIX shell (basic support)
  dash        Dash shell (basic support)
  ksh         Korn shell (basic support)
  powershell  Windows PowerShell (full support)
  pwsh        PowerShell Core (full support)

If [SHELL] is omitted, it is auto-detected from $SHELL environment variable.

Installation examples:
  # Bash
  caspaste --shell completions bash > ~/.local/share/bash-completion/completions/caspaste

  # Zsh
  caspaste --shell completions zsh > ~/.zsh/completions/_caspaste

  # Fish
  caspaste --shell completions fish > ~/.config/fish/completions/caspaste.fish

  # PowerShell
  caspaste --shell completions powershell > ~/Documents/PowerShell/completions/caspaste.ps1

Or add to shell rc file:
  # ~/.bashrc, ~/.zshrc
  eval "$(caspaste --shell init)"

  # ~/.config/fish/config.fish
  caspaste --shell init | source`)
}

func detectShell() string {
	shellPath := os.Getenv("SHELL")
	if shellPath == "" {
		// Default fallback
		return "bash"
	}
	// /bin/zsh â†’ zsh
	return filepath.Base(shellPath)
}

func printCompletions(shell, binaryName string) {
	switch shell {
	case "bash":
		fmt.Print(generateBashCompletions(binaryName))
	case "zsh":
		fmt.Print(generateZshCompletions(binaryName))
	case "fish":
		fmt.Print(generateFishCompletions(binaryName))
	case "sh", "dash", "ksh":
		fmt.Print(generatePosixCompletions(binaryName))
	case "powershell", "pwsh":
		fmt.Print(generatePowershellCompletions(binaryName))
	default:
		fmt.Fprintf(os.Stderr, "Unsupported shell: %s\n", shell)
		fmt.Fprintln(os.Stderr, "Supported: bash, zsh, fish, sh, dash, ksh, powershell, pwsh")
		os.Exit(1)
	}
}

func printInit(shell, binaryName string) {
	switch shell {
	case "bash":
		fmt.Printf("source <(%s --shell completions bash)\n", binaryName)
	case "zsh":
		fmt.Printf("source <(%s --shell completions zsh)\n", binaryName)
	case "fish":
		fmt.Printf("%s --shell completions fish | source\n", binaryName)
	case "sh", "dash", "ksh":
		fmt.Printf("eval \"$(%s --shell completions %s)\"\n", binaryName, shell)
	case "powershell", "pwsh":
		fmt.Printf("Invoke-Expression (& %s --shell completions powershell)\n", binaryName)
	default:
		fmt.Fprintf(os.Stderr, "Unsupported shell: %s\n", shell)
		fmt.Fprintln(os.Stderr, "Supported: bash, zsh, fish, sh, dash, ksh, powershell, pwsh")
		os.Exit(1)
	}
}

// IsServerBinary returns true if the binary name indicates it's a server
func IsServerBinary(name string) bool {
	lower := strings.ToLower(name)
	return !strings.Contains(lower, "-cli") && !strings.Contains(lower, "-agent")
}

func generateBashCompletions(binaryName string) string {
	isServer := IsServerBinary(binaryName)

	var commands, flags string
	if isServer {
		commands = ""
		flags = "--help --version --config --address --port --debug --status --maintenance --service --shell"
	} else {
		commands = "new create paste get show view list ls info server-info health healthz login config help version"
		flags = "--help --version --server --file --title --syntax --lifetime --one-use --private --raw --limit --offset --shell"
	}

	return fmt.Sprintf(`# Bash completion for %s
# Generated by %s --shell completions bash

_%s_completions() {
    local cur prev words cword
    _init_completion || return

    local commands="%s"
    local flags="%s"
    local shells="bash zsh fish sh dash ksh powershell pwsh"

    # Handle --shell subcommands
    if [[ "${words[1]}" == "--shell" ]]; then
        case "${cword}" in
            2)
                COMPREPLY=($(compgen -W "completions init --help" -- "${cur}"))
                return
                ;;
            3)
                COMPREPLY=($(compgen -W "${shells}" -- "${cur}"))
                return
                ;;
        esac
        return
    fi

    # Handle --syntax completion
    if [[ "${prev}" == "--syntax" || "${prev}" == "-s" ]]; then
        local syntaxes="plaintext go python javascript typescript rust java c cpp ruby php bash shell json yaml xml html css markdown sql"
        COMPREPLY=($(compgen -W "${syntaxes}" -- "${cur}"))
        return
    fi

    # Handle file completion
    if [[ "${prev}" == "--file" || "${prev}" == "-f" ]]; then
        _filedir
        return
    fi

    # Handle --config completion
    if [[ "${prev}" == "--config" ]]; then
        _filedir '@(yml|yaml)'
        return
    fi

    # Handle --maintenance completion
    if [[ "${prev}" == "--maintenance" ]]; then
        COMPREPLY=($(compgen -W "backup restore" -- "${cur}"))
        return
    fi

    # Handle --service completion
    if [[ "${prev}" == "--service" ]]; then
        COMPREPLY=($(compgen -W "install uninstall start stop restart reload status" -- "${cur}"))
        return
    fi

    # Complete commands or flags
    if [[ "${cur}" == -* ]]; then
        COMPREPLY=($(compgen -W "${flags}" -- "${cur}"))
    elif [[ ${cword} -eq 1 ]]; then
        COMPREPLY=($(compgen -W "${commands} ${flags}" -- "${cur}"))
    fi
}

complete -F _%s_completions %s
`, binaryName, binaryName, binaryName, commands, flags, binaryName, binaryName)
}

func generateZshCompletions(binaryName string) string {
	isServer := IsServerBinary(binaryName)

	var commands, opts string
	if isServer {
		commands = ""
		opts = `
    '--help[Show help message]' \
    '--version[Show version]' \
    '--config[Config file path]:file:_files -g "*.yml"' \
    '--address[Listen address]:address:' \
    '--port[Listen port]:port:' \
    '--debug[Enable debug mode]' \
    '--status[Show server status]' \
    '--maintenance[Maintenance operations]:operation:(backup restore)' \
    '--service[Service management]:operation:(install uninstall start stop restart reload status)' \
    '--shell[Shell completions]:subcommand:(completions init --help)'`
	} else {
		commands = `
    'new:Create a new paste'
    'create:Create a new paste'
    'paste:Create a new paste'
    'get:Get a paste by ID'
    'show:Get a paste by ID'
    'view:Get a paste by ID'
    'list:List pastes'
    'ls:List pastes'
    'info:Get server information'
    'server-info:Get server information'
    'health:Check server health'
    'healthz:Check server health'
    'login:Configure credentials'
    'config:Show configuration'
    'help:Show help'
    'version:Show version'`
		opts = `
    '--help[Show help message]' \
    '--version[Show version]' \
    '--server[Server URL]:url:' \
    '(-f --file)'{-f,--file}'[Read from file]:file:_files' \
    '(-t --title)'{-t,--title}'[Paste title]:title:' \
    '(-s --syntax)'{-s,--syntax}'[Syntax highlighting]:syntax:(plaintext go python javascript typescript rust java c cpp ruby php bash shell json yaml xml html css markdown sql)' \
    '(-l --lifetime)'{-l,--lifetime}'[Expiration time]:time:' \
    '(-1 --one-use)'{-1,--one-use}'[Delete after first view]' \
    '(-p --private)'{-p,--private}'[Private paste]' \
    '(-r --raw)'{-r,--raw}'[Raw output]' \
    '(-n --limit)'{-n,--limit}'[Limit results]:number:' \
    '(-o --offset)'{-o,--offset}'[Offset results]:number:' \
    '--shell[Shell completions]:subcommand:(completions init --help)'`
	}

	var subcommands string
	if commands != "" {
		subcommands = fmt.Sprintf(`
local -a commands
commands=(%s
)
_describe -t commands 'commands' commands
`, commands)
	}

	return fmt.Sprintf(`#compdef %s
# Zsh completion for %s
# Generated by %s --shell completions zsh

_%s() {
    local -a opts
    opts=(%s
    )

    _arguments -s -S $opts

    case "$state" in
        *)
            %s
            ;;
    esac
}

# Handle --shell subcommands
_%s_shell() {
    local -a shells
    shells=(
        'bash:Bash completions'
        'zsh:Zsh completions'
        'fish:Fish completions'
        'sh:POSIX shell completions'
        'dash:Dash completions'
        'ksh:Korn shell completions'
        'powershell:PowerShell completions'
        'pwsh:PowerShell Core completions'
    )
    _describe -t shells 'shell' shells
}

_%s "$@"
`, binaryName, binaryName, binaryName, binaryName, opts, subcommands, binaryName, binaryName)
}

func generateFishCompletions(binaryName string) string {
	isServer := IsServerBinary(binaryName)

	var commands, flags string
	if isServer {
		commands = ""
		flags = `
complete -c %s -l help -d 'Show help message'
complete -c %s -l version -d 'Show version'
complete -c %s -l config -d 'Config file path' -r -F
complete -c %s -l address -d 'Listen address' -r
complete -c %s -l port -d 'Listen port' -r
complete -c %s -l debug -d 'Enable debug mode'
complete -c %s -l status -d 'Show server status'
complete -c %s -l maintenance -d 'Maintenance operations' -r -xa 'backup restore'
complete -c %s -l service -d 'Service management' -r -xa 'install uninstall start stop restart reload status'`
		flags = fmt.Sprintf(flags, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName, binaryName)
	} else {
		commands = fmt.Sprintf(`
complete -c %s -f -n '__fish_use_subcommand' -a 'new' -d 'Create a new paste'
complete -c %s -f -n '__fish_use_subcommand' -a 'create' -d 'Create a new paste'
complete -c %s -f -n '__fish_use_subcommand' -a 'paste' -d 'Create a new paste'
complete -c %s -f -n '__fish_use_subcommand' -a 'get' -d 'Get a paste by ID'
complete -c %s -f -n '__fish_use_subcommand' -a 'show' -d 'Get a paste by ID'
complete -c %s -f -n '__fish_use_subcommand' -a 'view' -d 'Get a paste by ID'
complete -c %s -f -n '__fish_use_subcommand' -a 'list' -d 'List pastes'
complete -c %s -f -n '__fish_use_subcommand' -a 'ls' -d 'List pastes'
complete -c %s -f -n '__fish_use_subcommand' -a 'info' -d 'Get server information'
complete -c %s -f -n '__fish_use_subcommand' -a 'server-info' -d 'Get server information'
complete -c %s -f -n '__fish_use_subcommand' -a 'health' -d 'Check server health'
complete -c %s -f -n '__fish_use_subcommand' -a 'healthz' -d 'Check server health'
complete -c %s -f -n '__fish_use_subcommand' -a 'login' -d 'Configure credentials'
complete -c %s -f -n '__fish_use_subcommand' -a 'config' -d 'Show configuration'
complete -c %s -f -n '__fish_use_subcommand' -a 'help' -d 'Show help'
complete -c %s -f -n '__fish_use_subcommand' -a 'version' -d 'Show version'`,
			binaryName, binaryName, binaryName, binaryName, binaryName, binaryName,
			binaryName, binaryName, binaryName, binaryName, binaryName, binaryName,
			binaryName, binaryName, binaryName, binaryName)

		flags = fmt.Sprintf(`
complete -c %s -l help -d 'Show help message'
complete -c %s -l version -d 'Show version'
complete -c %s -l server -d 'Server URL' -r
complete -c %s -s f -l file -d 'Read from file' -r -F
complete -c %s -s t -l title -d 'Paste title' -r
complete -c %s -s s -l syntax -d 'Syntax highlighting' -r -xa 'plaintext go python javascript typescript rust java c cpp ruby php bash shell json yaml xml html css markdown sql'
complete -c %s -s l -l lifetime -d 'Expiration time' -r
complete -c %s -s 1 -l one-use -d 'Delete after first view'
complete -c %s -s p -l private -d 'Private paste'
complete -c %s -s r -l raw -d 'Raw output'
complete -c %s -s n -l limit -d 'Limit results' -r
complete -c %s -s o -l offset -d 'Offset results' -r`,
			binaryName, binaryName, binaryName, binaryName, binaryName, binaryName,
			binaryName, binaryName, binaryName, binaryName, binaryName, binaryName)
	}

	shellCompletions := fmt.Sprintf(`
# Shell completions
complete -c %s -l shell -d 'Shell completions' -r -xa 'completions init --help'
complete -c %s -n '__fish_seen_argument -l shell' -xa 'bash zsh fish sh dash ksh powershell pwsh'`,
		binaryName, binaryName)

	return fmt.Sprintf(`# Fish completion for %s
# Generated by %s --shell completions fish
%s
%s
%s
`, binaryName, binaryName, commands, flags, shellCompletions)
}

func generatePosixCompletions(binaryName string) string {
	isServer := IsServerBinary(binaryName)

	var words string
	if isServer {
		words = "--help --version --config --address --port --debug --status --maintenance --service --shell"
	} else {
		words = "new create paste get show view list ls info server-info health healthz login config help version --help --version --server --file --title --syntax --lifetime --one-use --private --raw --limit --offset --shell"
	}

	return fmt.Sprintf(`# POSIX shell completion for %s
# Generated by %s --shell completions sh
# Add to your shell profile for tab completion

_%s_complete() {
    local words="%s"
    local cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=($(compgen -W "$words" -- "$cur"))
}

complete -F _%s_complete %s
`, binaryName, binaryName, binaryName, words, binaryName, binaryName)
}

func generatePowershellCompletions(binaryName string) string {
	isServer := IsServerBinary(binaryName)

	var commands, flags string
	if isServer {
		commands = ""
		flags = "@('--help', '--version', '--config', '--address', '--port', '--debug', '--status', '--maintenance', '--service', '--shell')"
	} else {
		commands = "@('new', 'create', 'paste', 'get', 'show', 'view', 'list', 'ls', 'info', 'server-info', 'health', 'healthz', 'login', 'config', 'help', 'version')"
		flags = "@('--help', '--version', '--server', '-f', '--file', '-t', '--title', '-s', '--syntax', '-l', '--lifetime', '-1', '--one-use', '-p', '--private', '-r', '--raw', '-n', '--limit', '-o', '--offset', '--shell')"
	}

	return fmt.Sprintf(`# PowerShell completion for %s
# Generated by %s --shell completions powershell

Register-ArgumentCompleter -Native -CommandName %s -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commands = %s
    $flags = %s
    $shells = @('bash', 'zsh', 'fish', 'sh', 'dash', 'ksh', 'powershell', 'pwsh')
    $syntaxes = @('plaintext', 'go', 'python', 'javascript', 'typescript', 'rust', 'java', 'c', 'cpp', 'ruby', 'php', 'bash', 'shell', 'json', 'yaml', 'xml', 'html', 'css', 'markdown', 'sql')
    $maintenanceOps = @('backup', 'restore')
    $serviceOps = @('install', 'uninstall', 'start', 'stop', 'restart', 'reload', 'status')
    $shellSubcmds = @('completions', 'init', '--help')

    $elements = $commandAst.CommandElements
    $lastWord = if ($elements.Count -gt 1) { $elements[-1].Extent.Text } else { '' }
    $secondLastWord = if ($elements.Count -gt 2) { $elements[-2].Extent.Text } else { '' }

    # Handle --shell subcommands
    if ($secondLastWord -eq '--shell') {
        if ($lastWord -eq 'completions' -or $lastWord -eq 'init') {
            $shells | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
            return
        }
        $shellSubcmds | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
        return
    }

    # Handle --syntax completion
    if ($lastWord -eq '--syntax' -or $lastWord -eq '-s') {
        $syntaxes | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
        return
    }

    # Handle --maintenance completion
    if ($lastWord -eq '--maintenance') {
        $maintenanceOps | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
        return
    }

    # Handle --service completion
    if ($lastWord -eq '--service') {
        $serviceOps | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
        return
    }

    # Complete commands and flags
    $allCompletions = $commands + $flags
    $allCompletions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}
`, binaryName, binaryName, binaryName, commands, flags)
}
